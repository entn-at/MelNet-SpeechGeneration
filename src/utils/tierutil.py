"""
This module implements the functions to split and interleave spectrograms as explained in MelNet
paper Section 6 to enable multiscale modelling. It also contains some other useful functions to
calculate the size of the frequency and time dimensions depending on the number of tiers of the
model.
"""

from typing import Tuple

from torch import Tensor
import torch


def split(spectrogram: Tensor, tier: int, n_tiers: int) -> Tuple[Tensor, Tensor]:
    """
    Split complete spectrogram to generate x_g and x_<g (x_lg) according to MelNet formula (24):
    x_g, x_<g = split(x_<g+1)

    Args:
        spectrogram (Tensor): original spectrogram to split. Shape: [B, FREQ, FRAMES]
        tier (int): tier to use for splitting (in the formula is g=tier)
        n_tiers (int): number of tiers that the models has. Needed to know where to start splitting.

    Returns:
        x_<g, x_g (Tensor): both with shape [B, FREQ/2, FRAMES] if g is even or [B, FREQ, FRAMES/2]
                            if g is odd. Note: order is inverted with respect the formula.
    """
    tiers = list()

    for i in range(n_tiers, max(0, tier - 1), -1):
        if i == 1:
            tiers.insert(0, (spectrogram, spectrogram))  # first tier has unconditional generation
        elif i % 2 == 0:
            # divide by frequency axis
            tiers.insert(0, (spectrogram[:, ::2, :], spectrogram[:, 1::2, :]))
            spectrogram = spectrogram[:, ::2, :]
        else:
            # divide by time axis
            tiers.insert(0, (spectrogram[:, :, ::2], spectrogram[:, :, 1::2]))
            spectrogram = spectrogram[:, :, ::2]

    # Because we reach the tier that we want in the last iteration, we return the first element.
    # If size of dimensions is not a power of two, the shape will be a little different so we make
    # them the same size. (i.e. FRAMES=99 -> time shape would be 50 and 49)
    B0, FREQ0, FRAMES0 = tiers[0][0].shape
    B1, FREQ1, FRAMES1 = tiers[0][1].shape
    FREQ, FRAMES = min(FREQ0, FREQ1), min(FRAMES0, FRAMES1)

    return tiers[0][0][:, :FREQ, :FRAMES], tiers[0][1][:, :FREQ, :FRAMES]


def interleave(x_g: Tensor, x_lg: Tensor, tier: int) -> Tensor:
    """
    Interleave spectrograms x_g and x_<g (x_lg) generated by different tiers according to MelNet
    formula (25): x_<g+1 = interleave(x_g, g_<g)

    Args:
        x_g (Tensor): spectrogram generated by tier g. Shape: [B, FREQ, FRAMES]
        x_lg (Tensor): spectrogram generated by interleaving the spectrograms generated by tiers
                       less than g. Shape: [B, FREQ, FRAMES]
        tier (int): tier to interleave (generate) (in the formula g=tier)

    Returns:
        x_<g+1 (Tensor): tensor after interleaving. Shape: [B, FREQ*2, FRAMES] if tier is even or
                         [B, FREQ, FRAMES*2] if tier is odd.
    """
    assert x_g.shape == x_lg.shape

    B, FREQ, FRAMES = x_g.shape

    if tier % 2 == 0:
        # interleave along frequency axis
        temp = torch.zeros([B, FREQ * 2, FRAMES])
        temp[:, ::2, :] = x_lg
        temp[:, 1::2, :] = x_g
        return temp
    else:
        # interleave along time axis
        temp = torch.zeros([B, FREQ, FRAMES * 2])
        temp[:, :, ::2] = x_lg
        temp[:, :, 1::2] = x_g
        return temp


def get_size_freqdim_of_tier(n_mels: int, n_tiers: int, tier: int) -> int:
    """
    Calculates the size of the frequency dimension for the nth tier from the original size of the
    frequency dimension (n_mels).

    Args:
        n_mels (int): mel channels of the original (or final) spectrogram.
        n_tiers (int): number of tiers that the model has.
        tier (int): tier to calculate the size of the frequency dimension.

    Returns:
        frequency dimension size (int): for the specified tier.
    """
    # Because of the Multiscale Modelling, every tier produces an output of different sizes in the
    # frequency and time dimension. Following the example of the MelNet figure 5:
    #
    #                Shape for synthesis
    #                (FREQxFRAMES (time))        Output  Together
    #  Tier nÂº |  Input   Output  Together Axis Relation Relation|
    #  tier 1  |     -    32x50    32x50    -     8:4       8:4  |
    #  tier 2  |  32x50   32x50    64x50   (f)    8:4       4:4  |
    #  tier 3  |  64x50   64x50    64x100  (t)    4:4       4:2  |
    #  tier 4  |  64x100  64x100  128x100  (f)    4:2       2:2  |
    #  tier 5  | 128x100 128x100  128x200  (t)    2:2       2:1  |
    #  tier 6  | 128x200 128x200  256x200  (f)    2:1       1:1  |
    #                                ^-- final size
    #
    # In the input shape we can see the shape that the input spectrogram will have for that
    # tier (tier 1 is unconditional). In the output shape we can see the shape that the output
    # will have for that tier. In the together shape we can see the spectrogram shape after
    # interleaving the output of that tier and the spectrograms of the previous tier. The axis is
    # the axis used for interleaving (frequency or time). The output relation (the input relation
    # would have the same values) is the amount by which every dimension has been downsampled.
    #
    # From this table, we can see that the formula for getting the size of the frequency dimension
    # from the original dimension is: frequency = n_mels / (2 ^ frequency_passes)
    if n_tiers == 1:
        return n_mels

    # tier1 is unconditional and always has the shape (frequency and time) of the second tier
    tier = tier if tier > 1 else 2

    if n_tiers % 2 == 0:
        frequency_passes = (n_tiers - tier) // 2 + 1  # + 1 because n_tiers is odd and we start
                                                      # splitting by time axis
    else:
        frequency_passes = (n_tiers - (tier - 1)) // 2
    return n_mels // (2 ** frequency_passes)


def get_size_timedim_of_tier(timesteps: int, n_tiers: int, tier: int) -> int:
    """
    Calculates the size of the time dimension for the nth tier from the original size of the
    time dimension (timesteps).

    Args:
        timesteps (int): frames of the original (or final) spectrogram.
        n_tiers (int): number of tiers that the model has.
        tier (int): tier to calculate the size of the frequency dimension.

    Returns:
        time dimension size (int): for the specified tier.
    """
    if n_tiers == 1:
        return timesteps

    # See explanation in previous function:
    # From this table, we can see that the formula for getting the size of the time dimension
    # from the original dimension is: frames = timesteps / (2 ^ time_passes)

    # tier1 is unconditional and always has the shape (frequency and time) of the second tier
    tier = tier if tier > 1 else 2

    if n_tiers % 2 == 0:
        time_passes = (n_tiers - (tier - 1)) // 2
    else:
        time_passes = (n_tiers - tier) // 2 + 1  # + 1 because n_tiers is odd and we start
                                                 # splitting by time axis
    return timesteps // (2 ** time_passes)
